<!--
 * @Author: liyunfang
 * @Date: 2020-01-27 15:04:59
 * @LastEditTime : 2020-01-29 01:41:21
 * @Description: 
 -->
# 第12章

## 练习 12.1

b1 4个元素，b2被销毁

## 练习 12.3

不该加，因为常量不该被`push_back``pop_back`

## 练习 12.4

`size_t` 是 `unsigned`

## 练习 12.5

构造函数不是 explicit 的，意味着可以从 initializer_list 隐式转换为 StrBlob。在 StrBlob 对象中，只有一个数据成员 data，而 StrBlob 对象本身的含义，也是一个管理字符串的序列。因此，从 initializer_list 到 StrBlob 的转换，在逻辑上是可行的。而这个设计策略的缺点，可能在某些地方我们确实需要 initializer_list，而编译器仍会将之转换为 StrBlob。

## 练习 12.8

`p` 转换成`bool`，动态内存无法释放

## 练习 12.9

`r` 和 `q` 指向同一块动态内存，使得`r`之前指向的动态内存得不到释放，由于`q2`和`r2`是智能内存，不会出现这种情况

## 练习 12.10

正确

## 练习 12.11

`p` 变成空悬指针

## 练习 12.12

- (a) 合法。将sp 拷贝给 process函数的形参，在函数里面引用计数为 2，函数结束后引用计数为 1。
- (b) 不合法。不能从内置指针隐式转换为智能指针。
- (c) 不合法。不能从内置指针隐式转换为智能指针。
- (d) 合法。但是智能指针和内置指针一起使用可能会出现问题，在表达式结束后智能指针会被销毁，它所指向的对象也被释放。而此时内置指针 p 依旧指向该内存空间。之后对内置指针 p 的操作可能会引发错误。

## 练习 12.13

`sp`变成空悬指针

## 练习 12.17

- (a) 不合法。在定义一个 unique_ptr 时，需要将其绑定到一个new 返回的指针上。
- (b) 可以编译通过。但是可能会有后续的程序错误。当 p1 被释放时，它试图释放一个栈空间的对象。
- (c) 合法。但是也可能会使得 pi2 成为空悬指针。
- (d) 不合法。当 p3 被销毁时，它试图释放一个栈空间的对象。
- (e) 合法。
- (f) 不合法。p5 和 p2 指向同一个对象，当 p5 和 p2 被销毁时，会使得同一个指针被释放两次。

## 练习 12.18

release 成员的作用是放弃控制权并返回指针，因为在某一时刻只能有一个 unique_ptr 指向某个对象，unique_ptr 不能被赋值，所以要使用 release 成员将一个 unique_ptr 的指针的所有权传递给另一个 unique_ptr。而 shared_ptr 允许有多个 shared_ptr 指向同一个对象，因此不需要 release 成员。

## 练习 12.21

原来的可读性更好
