# 第 6 章 练习

## 练习 6.1

**形参**：在函数形参列表里声明的局部变量。
**实参**：形参第初始值。

## 练习 6.2

(a) 实际返回类型与函数定义的返回类型不符
(b) 函数未定义返回类型
(c) 任意两个形参不能同名
(d) 函数体必须是语句块

## [练习 6.3](ch06/ex6_3.cpp)

## [练习 6.4](ch06/ex6_4.cpp)

## [练习 6.5](ch06/ex6_5.cpp)

## 练习 6.6

形参是局部变量的一种，局部静态变量相对于局部变量在语句块外不被销毁但是不可调用。

## [练习 6.7](ch06/ex6_7.cpp)

## [练习 6.8](ch06/Chapter6.h)

## 练习 6.9（[fact.cc](ch06/fact.cc), [factMain.cc](ch06/factMain.cc)）

## [练习 6.10](ch06/ex6_10.cpp)

## [练习 6.11](ch06/ex6_11.cpp)

## [练习 6.12](ch06/ex6_12.cpp)

## 练习 6.13

`void f(T)` 传值进函数，`void f(&T)`形参以引用的形式绑定在实参上。

## 练习 6.14

形参是引用类型：`reset`函数
形参不能是引用类型：以我的理解，需要改变指向的对象的时候，比如迭代器。

## 练习 6.15

函数的目的不需要改变`s`的值，且`s`可能很大，复制就很低效
`occurs`需要改变外部值
`c`有可能直接传个右值
`s`普通引用可能会在函数里被改变。

## 练习 6.16

无法传右值以及常值，形参改为常量引用

## [练习 6.17](ch06/ex6_17.cpp)

形参不同，因为一个要改变实参，一个不用。

## 练习 6.18

```cpp
bool compare(const matrix &m1, const matrix &m2);
vector<int>::iterator change_val(const int &var, vector<int>::iterator iter);
```

## 练习 6.19

a) 不合法，多传入了实参
b) 合法
c) 合法
d) 合法

## 练习 6.20

不需要改变传入的实参值的时候

1. 不安全，可能会在函数里改变实参值
2. 无法用右值初始化形参

## [练习 6.21](ch06/ex6_21.cpp)

`const int *const` 更好

## [练习 6.22](ch06/ex6_22.cpp)

这里似乎无法保证函数不改变`int`对象的值？

## [练习 6.23](ch06/ex6_23.cpp)

## 练习 6.24

形参是个指向整型数组的指针，无法用index

## [练习 6.25 & 6.26](ch06/ex6_25.cpp)

## [练习 6.27](ch06/ex6_27.cpp)

## 练习 6.28

`const string &` ps: 貌似在 `auto` 前加 `const` 出来的也是 `const string &`，和 `initializer_list` 有关？

## 练习 6.29

这取决于`initializer_list`的元素类型，如果是`int` `char`这种，用拷贝也无可厚非

## [练习 6.30](ch06/ex6_30.cpp)

Clang\MSVC\gcc: 没有返回值，修正第一个错误后才会给第二处警告。

## 练习 6.31

返回的引用是局部变量时，但是这个和编译器有关。返回常量当引用在声明函数返回类型时未加`const`时无效。

## 练习 6.32

合法。`get`函数根据索引取得数组中的元素的引用。

## [练习 6.33](ch06/ex6_33.cpp)

## 练习 6.34

如果`val`为正数，多乘了一个1，如果为负数，递归永不停止。

## 练习 6.35

函数参数永远传入的值是`val`，递归永不停止。

## 练习 6.36

```cpp
int (*fun(T arg))[10];
```

## 练习 6.37

```cpp
typedef int arrT[10];
arrT& func(int i);

auto func(int i) -> int (&) [10];

int arr[10];
decltype(arr) &func(int i);
```

当然是尾置返回类型吼啊！

## 练习 6.38

```cpp
decltype(odd) &arrPtr(int i)
{
    return (1 % 2) ? odd : even;
}
```
