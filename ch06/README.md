# 第 6 章 练习

## 练习 6.1

**形参**：在函数形参列表里声明的局部变量。
**实参**：形参第初始值。

## 练习 6.2

(a) 实际返回类型与函数定义的返回类型不符
(b) 函数未定义返回类型
(c) 任意两个形参不能同名
(d) 函数体必须是语句块

## [练习 6.3](ch06/ex6_3.cpp)

## [练习 6.4](ch06/ex6_4.cpp)

## [练习 6.5](ch06/ex6_5.cpp)

## 练习 6.6

形参是局部变量的一种，局部静态变量相对于局部变量在语句块外不被销毁但是不可调用。

## [练习 6.7](ch06/ex6_7.cpp)

## [练习 6.8](ch06/Chapter6.h)

## 练习 6.9（[fact.cc](ch06/fact.cc), [factMain.cc](ch06/factMain.cc)）

## [练习 6.10](ch06/ex6_10.cpp)

## [练习 6.11](ch06/ex6_11.cpp)

## [练习 6.12](ch06/ex6_12.cpp)

## 练习 6.13

`void f(T)` 传值进函数，`void f(&T)`形参以引用的形式绑定在实参上。

## 练习 6.14

形参是引用类型：`reset`函数
形参不能是引用类型：以我的理解，需要改变指向的对象的时候，比如迭代器。

## 练习 6.15

函数的目的不需要改变`s`的值，且`s`可能很大，复制就很低效
`occurs`需要改变外部值
`c`有可能直接传个右值
`s`普通引用可能会在函数里被改变。

## 练习 6.16

无法传右值以及常值，形参改为常量引用

## [练习 6.17](ch06/ex6_17.cpp)

形参不同，因为一个要改变实参，一个不用。

## 练习 6.18

```cpp
bool compare(const matrix &m1, const matrix &m2);
vector<int>::iterator change_val(const int &var, vector<int>::iterator iter);
```

## 练习 6.19

a) 不合法，多传入了实参
b) 合法
c) 合法
d) 合法

## 练习 6.20

不需要改变传入的实参值的时候

1. 不安全，可能会在函数里改变实参值
2. 无法用右值初始化形参
